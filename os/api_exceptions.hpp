/** @file os/api_exceptions.hpp
 *  @brief jel Exception type definitions.
 *
 *  @detail
 *    Various jel elements make use of exceptions for reporting certain types of errors. Generally
 *    the exception philosophy is such that where possible Status codes will report the success or
 *    failure of most operations, particularly those that are performed often (for example,
 *    acquiring a mutex). Operations that cannot return an error code (i.e. constructors) or unusual
 *    operations that will likely require handling significantly higher up the stack (failed to
 *    configure driver hardware, for example) may thrown an exception. jel Exceptions are designed
 *    such that, in debug builds with assertions enabled, they provide full printf style error
 *    reporting. If NDEBUG is defined, only a dedicated exception code will be returned. Note that
 *    the printf debug error handling is quite expensive and requires additional allocations,
 *    although it does allow propagation of an error message up the entire stack.
 *
 *  @author Jonathan Thomson 
 */
/**
 * MIT License
 * 
 * Copyright 2018, Jonathan Thomson 
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#pragma once

/** C/C++ Standard Library Headers */
#include <exception>
#include <cstdio>
#include <cstdarg>
#include <cstring>

/** jel Library Headers */
#include "os/api_common.hpp"

#ifdef NDEBUG
#define JEL_DISABLE_EXCEPTION_PRINTF_SUPPORT
#endif

namespace jel
{

/** ID reserved by the os module in jel. */
static constexpr int32_t RESERVED_OS_MODULE_ID = 0x1;
/** ID reserved by the hw module in jel. */
static constexpr int32_t RESERVED_HW_MODULE_ID = 0x2;

/** @class Exception_Base
 *  @brief Provides the source template for all jel exceptions.
 *
 *  All exceptions generated by jel are sourced from this class (aside from instances where STL
 *  exceptions may propagate upwards). jel Exceptions are defined by two elements: A system wide
 *  unique module ID code (a signed integer) and an error code. Each module inherits from the
 *  Exception_Base class template and constructs all exceptions with their own unique codes. Within
 *  the jel, these codes are of an enum type based around a 32b integer. 
 *  Additional debugging support is also provided which allows for printf style use of exceptions
 *  where they will propagate upwards with an error message generated at the throw location. This
 *  behavior requires additional allocations and is significantly slower, however, so is
 *  automatically disabled if the NDEBUG flag is set (or, more specifically, the
 *  JEL_DISABLE_EXCEPTION_PRINTF_SUPPORT. This is tied to NDEBUG by default). 
 *
 *  The following module codes are reserved by jel:
 *    -Any code < 0.
 *    -0x0: This is considered invalid.
 *    -0x1: This is reserved for the os module.
 *    -0x2: This is reserved for the hw module.
 *    -0x3 through 0xF: These are reserved for future additions.
 *
 * */
template<int32_t moduleId, class T>
class Exception_Base : public std::exception
{
public:
  /** Module ID code. Exceptions are generally tied to a global integer ID that should be unique for
   * all modules. */
  const int32_t module; 
  /** Error code. The exact error code type is dependent on the module. */
  const T error; 
  Exception_Base(const T code, const char* message, ...) __attribute__((format(printf, 3, 4))) : 
    module(moduleId), error(code) 
  {
#ifndef JEL_DISABLE_EXCEPTION_PRINTF_SUPPORT
    va_list args; va_start(args, message);
    int bufSize = std::vsnprintf(nullptr, 0, message, args); 
    errorString = new char[bufSize]; 
    std::vsnprintf(errorString, bufSize, message, args);
    va_end(args); 
#else
    (void)message;
#endif
  }
  ~Exception_Base()
  {
#ifndef JEL_DISABLE_EXCEPTION_PRINTF_SUPPORT
    if(errorString)
    {
      delete[] errorString;
    }
#endif
  }
  Exception_Base(Exception_Base&& rhs) : module(rhs.exMod), error(rhs.exCode)
  {
#ifndef JEL_DISABLE_EXCEPTION_PRINTF_SUPPORT
    this->exMsg = rhs.exMsg;
    rhs.exMsg = nullptr;  
#else
   this->exMsg = rhs.exMsg;
#endif
  }
  Exception_Base(const Exception_Base& rhs) : module(rhs.exMod), error(rhs.exCode)
  {
#ifndef JEL_DISABLE_EXCEPTION_PRINTF_SUPPORT
    errorString = new char[std::strlen(rhs.exMsg) + 1];
    std::strcpy(errorString, rhs.exMsg);
#else
#endif
  }
  /** Returns the human readable fault message string. */
  const char* what() const noexcept final override 
  { 
#ifndef JEL_DISABLE_EXCEPTION_PRINTF_SUPPORT
    return errorString;
#else
    return "Error messages are only available when NDEBUG is undefined.";
#endif
  }
private:
#ifndef JEL_DISABLE_EXCEPTION_PRINTF_SUPPORT
  char* errorString; 
#endif
};

namespace os
{

enum class ExceptionCode : uint32_t
{
  allocationFailed = 0,
  lockConstructionFailed,
};

class Exception : public Exception_Base<RESERVED_OS_MODULE_ID, ExceptionCode>
{
public:
  template<typename ... A>
  Exception(const ExceptionCode& code, const char* msg, A&& ... printfArgs) :
    Exception_Base<RESERVED_OS_MODULE_ID, ExceptionCode>(code, msg, std::forward<A>(printfArgs) ...)
    {}
};

}

}
